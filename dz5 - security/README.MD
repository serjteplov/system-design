
# Задание
Вам нужно спроектировать безопасную архитектуру системы, включающую механизмы аутентификации, авторизации, защиты данных при передаче, а также управление секретами. Задача направлена на интеграцию изученных технологий для создания надёжного и масштабируемого решения, устойчивого к внешним и внутренним угрозам.

# Непокрытые поинты
Где будет ТЛС терминэйшн
ТЛС с Редис, Кафкой, Постгрёй
Хранение сертов не в файловой система, а в SPIFFE, Istio, Vault


# Архитектура системы


# 1. Аутентификация и авторизация

Используемые технологии: OAuth2.0, OIDC, JWT
### Флоу №1. Получение Access token
Пользователь редиректится на страницу Keycloak где он вводит логин/пароль. В этот момент Keycloak через LDAP identity provider проверят валидность кредов, и если все ок то на фронт отдаётся auth_code и ID_token. С этого момента мы считаем пользователя аутентифицированным. Затем фронт обменивает auth_code на access_token, это делается отдельным запросом к keycloak. Теперь у пользователя через фронтальное приложение есть право пользоваться нашим бэкэндом. Access_token будет проверяться на уровне API Gateway и в некоторых случаях на конечном бэкэнд сервисе.
### Флоу №2. Получение Access token через стороннего Identity Provider
В случае если пользователь решил залогиниться через стороннего IdP, например через Google, auth flow немного изменится. Разлогиненный пользователь попадает на экран логина и нажимает "войти с использованием Google". Он попадает на экран гугла ввода логина/пароля. После успешного ввода credentials, гугл спрашивает разрешение у пользователя доверять приложению и какие данные можно ему передать. Пользователь выбирает. И далее гугл редиректит фронтальное приложение обратно на Keycloak и присоединяет к запросу ID-token, в виде JWT в payload которого указаны основные данные о пользователе: email, sub, фио, и пр. Keycloak, получив данный id-token, который подписан сертом гугл, считает с этого момента что пользователь успешно аутентифицировался, и передает на фронт Id token и свой auth_code. Фронт делает запрос на эндпоинт получения токенов, далее бэкэнд этого эндпоинта меняет auth_code на AT, возвращает на фронт AT и одновременно кладет AT в Redis кэш. Теперь фронт, имея AT, может осуществлять авторизованные вызовы бэкэнда. В нашем случает AT будет в виде строки (не JWT), для проверки токена обязателен вызов Keycloak.
### Флоу №3. Сценарии экспирации и обновления токенов
Фронт следит за временем истечения access token (ат). За 3 минуты (параметр конфигурируемый) до истечения ат, фронт вызывает на бэкэнде эндпоинт обновления токена. На вход в эндпоинт, фронт передает текущий ат. Далее бэкэнд достает из защищенного хранилища refresh token (рт) и идёт в Keycloak с парой ат+рт. Бэкэнд получает от Keycloak новую пару ат и рефреш токена (рт), возвращает на фронт ат и обновляет ат в Redis кэш. Access токен передаёся в httponly cookie, фронт продолжает работать с приложением без перелогина пользователя.

# 2. Безопасность передачи данных
* Поддерживается HTTPS с версиями TLS 1.2/1.3 на сертификатах Global Sign. Сертификаты хранятся в файловой системе, перевыпуск ручной
* Внутри сети mTLS на самоподписанных сертификатах, управление сертификатами в side car Istio. Сертификаты хранятся в поде, перевыпуск автоматический
* Load Balancer отправляет заголовок HSTS, чтобы браузер всегда загружал сайт по https
* PFS настроен на узле где происходит TLS termination, у нас это Load Balancer
* Cookie защищены HttpOnly и Secure. SameSite - не используем из-за возможных кросс-доменных запросов
* Для передачи данных банковской карты, например card number и expire date, одного HTTPS недостаточно, потому что на фронте нужна дополнительная степень защиты от атак, таких как XSS. Card number и expire date хранятся на бэкэнде, шифруются симметричным алгоритмом, затем ключ шифруется ассиметричным алгоритмом, и весь комплект данных передается на фронт. 

# 3. Управление доступами
В OpenLDAP хранятся данные о пользователях: логины, пароли, роли. Если нужно добавить/изменить роль пользователя, администратор заходит в OpenLDAP через web интерфейс и вносит изменения. Каждому логину соответсвует определенная роль. После этого в access token в payload Keycloak сможет записывать эту роль. Политики доступа хранятся в OpenLDAP, Keycloak, API Gateway, в конфиге микросервиса. Автоматизацию проверок политик можно делать через скрипты, авто тесты, мониторинг.

Описание процесса применения RBAC. Когда пользователь успешно проходит аутентификацию и получает access token в виде JWT, то с фронта уходит запрос на бэкэнд. Достигнув API Gateway из запроса извлекается токен, проверяется на валидность, и из payload JWT извлекается роль. Таким образом, на API Gateway становится известна роль пользователя, а также другие атрибуты, например user_id, scopes, iss, sub. Далее API Gateway в соответсвии со своим конфигом маршрутов пускает или не пускает запрос дальше на бэкэнд. Если запрос пропущен дальше, API Gateway добавляет роль в http-заголовок запроса. На микросервисе роль извлекается из заголовка, и в соответсвии с кодом микросервиса (например аннотациями Spring Security), принимается решение о выполнении кода эндпоинта.

# 4. Хранение и управление секретами
* Токены, которые получает микросервис для доступа к другим сервисам в ландшафте, хранятся в оперативной памяти микросервиса, за хранение отвечает Spring Security.
* Ключи шифрования хранятся в файловой системе сервера где развернут Кубер и монтируются в под при раскатке микросервиса.
* Конфигурации, в которых есть сенсетивные данные, хранятся в зашифрованном виде в Git.
* Пароли хранятся в Kubernetes secret и монтируются в ENV. Микросервис ходит в БД под своими собственными кредами. Эти креды микросервис загружает в память при старте из ENV переменных пода. В ENV креды попадают при раскатке приложения в Kubernetes. В деплоймент манифесте по раскатке пода указывается что ENV будут созданы из Kubernetes Secret. А в деплоймент манифест креды кладёт Helm, который читает зашифрованный конфиг файл из Git, расшифровывает его, читает от туда пароли, а затем кладет их в формате base64 в Kubernetes Secret.
* Ротация паролей выглядит следующим образом. По расписанию поддержка или девопсы меняют пароль микросервиса к своей БД . Девопс инженер скачивает из Git зашифрованный конфиг файл, расшифровывает его, прописывает новый пароль, потом зашифровывает обратно, и делает push в Git.

# 5. Мониторинг и аудит безопасности















