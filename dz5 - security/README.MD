
# Задание
Вам нужно спроектировать безопасную архитектуру системы, включающую механизмы аутентификации, авторизации, защиты данных при передаче, а также управление секретами. Задача направлена на интеграцию изученных технологий для создания надёжного и масштабируемого решения, устойчивого к внешним и внутренним угрозам.

# Архитектура системы
![sceme](https://github.com/serjteplov/system-design/blob/945ae888a341d7fafaf27dd2ffe0494ebcf34feb/dz5%20-%20security/scheme.jpg)

# 1. Аутентификация и авторизация
![auth](https://github.com/serjteplov/system-design/blob/945ae888a341d7fafaf27dd2ffe0494ebcf34feb/dz5%20-%20security/auth.png)

Используемые технологии: OAuth2.0, OIDC, JWT
### Флоу №1. Получение Access token
Пользователь редиректится сначала на Security Backend, потом на страницу Keycloak где он вводит логин/пароль. В этот момент Keycloak через LDAP identity provider проверят валидность кредов, и если все ок то на Security Backend, который отдает на фронт auth_code и ID_token. С этого момента мы считаем пользователя аутентифицированным. Затем фронт обменивает auth_code на access_token, это делается отдельным запросом к keycloak через Security Backend. Security Backend сохраняет в Redis аксес токен, и сохраняет в своей БД refresh токен. Теперь у пользователя через фронтальное приложение есть право пользоваться нашим бэкэндом. Access_token будет проверяться на уровне API Gateway и в некоторых случаях на конечном бэкэнд сервисе.
### Флоу №2. Получение Access token через стороннего Identity Provider
В случае если пользователь решил залогиниться через стороннего IdP, например через Google, auth flow немного изменится. Разлогиненный пользователь попадает на экран логина и нажимает "войти с использованием Google". Он попадает на экран гугла ввода логина/пароля. После успешного ввода credentials, гугл спрашивает разрешение у пользователя доверять приложению и какие данные можно ему передать. Пользователь выбирает. И далее гугл редиректит фронтальное приложение обратно на Keycloak и присоединяет к запросу ID-token, в виде JWT в payload которого указаны основные данные о пользователе: email, sub, фио, и пр. Keycloak, получив данный id-token, который подписан сертом гугл, считает с этого момента что пользователь успешно аутентифицировался, и передает на фронт Id token и свой auth_code. Фронт делает запрос на эндпоинт получения токенов, далее бэкэнд этого эндпоинта меняет auth_code на AT, возвращает на фронт AT и одновременно кладет AT в Redis кэш. Теперь фронт, имея AT, может осуществлять авторизованные вызовы бэкэнда. В нашем случает AT будет в виде строки (не JWT), для проверки токена обязателен вызов Keycloak.
### Флоу №3. Сценарии экспирации и обновления токенов
TTL токенов = 5 мин. Фронт следит за временем истечения access token (ат). За 15 сек (параметр конфигурируемый) до истечения ат, фронт вызывает на бэкэнде Security Backend эндпоинт обновления токена. На вход в эндпоинт, фронт передает текущий ат. Далее бэкэнд достает из защищенного хранилища refresh token (рт) и идёт в Keycloak с парой ат+рт. Security Backend получает от Keycloak новую пару ат и рефреш токена (рт), возвращает на фронт ат и обновляет ат в Redis кэш. Access токен передаёся в httponly cookie, фронт продолжает работать с приложением без перелогина пользователя.
В случае если бы АТ был бы в виде JWT с проверкой на бэкэнде, то можно было бы добавить grace period истечения токена равный 30 сек, если токен протух, то в течении 30 сек мы еще считаем его валидным. Это делается для предоставления запаса времени на получение новых токенов. Но т.к. у нас токен opaque с интроспекцией на Keycloak, данный прием сделать не получится.

# 2. Безопасность передачи данных
* Поддерживается HTTPS с версиями TLS 1.2/1.3. Сертификаты хранятся в файловой системе, перевыпуск ручной. Сертификаты выпущены в международном УЦ и принимаются всеми браузерами и приложениями, работающими по всему миру
* Внутри сети mTLS на самоподписанных сертификатах, управление сертификатами в side car Istio. Сертификаты хранятся в поде, перевыпуск автоматический
* Load Balancer отправляет заголовок HSTS, чтобы браузер всегда загружал сайт по https
* PFS настроен на узле где происходит TLS termination, у нас это Load Balancer
* Cookie защищены HttpOnly и Secure. SameSite - не используем из-за возможных кросс-доменных запросов
* Для передачи данных банковской карты, например card number и expire date, одного HTTPS недостаточно, потому что на фронте нужна дополнительная степень защиты от атак после TLS termination, таких как XSS, вредоносные программы, кейлогеры, скомпрометированные JS которые могут извлечь сенсетивные данные из DOM модели. Card number и expire date хранятся на бэкэнде, шифруются симметричным алгоритмом, затем ключ шифруется ассиметричным алгоритмом, и весь комплект данных передается на фронт. Либо использовать альтернативный подход - UI-маскирование, когда на фронт с бэка приходит **** **** **** 1234. Такую строку шифровать не надо.

# 3. Управление доступами
![RBAC](https://github.com/serjteplov/system-design/blob/945ae888a341d7fafaf27dd2ffe0494ebcf34feb/dz5%20-%20security/RBAC.png)

В OpenLDAP хранятся данные о пользователях: логины, пароли, роли. Если нужно добавить/изменить роль пользователя, администратор заходит в OpenLDAP через web интерфейс и вносит изменения. Каждому логину соответсвует определенная роль. После внесения администратором изменений в OpenLDAP, Keycloak сможет записывать эту роль в access token. Политики доступа хранятся в OpenLDAP, Keycloak, API Gateway, в конфиге микросервиса. Автоматизацию проверок политик можно делать через скрипты, авто тесты, мониторинг.

Описание процесса применения RBAC. Когда пользователь успешно проходит аутентификацию и получает access token в виде JWT, то с фронта уходит запрос на бэкэнд. Достигнув API Gateway из запроса извлекается токен, проверяется на валидность, и из payload JWT извлекается роль. Таким образом, на API Gateway становится известна роль пользователя, а также другие атрибуты, например user_id, scopes, iss, sub, которые нужны для выявления соответсвия политикам доступа. Далее API Gateway в соответсвии со своим конфигом маршрутов пускает или не пускает запрос дальше на бэкэнд. Если запрос пропущен дальше, API Gateway добавляет роль в http-заголовок запроса и отправляет на микросервис. На микросервисе роль извлекается из заголовка, и в соответсвии с кодом микросервиса (например аннотациями Spring Security), принимается решение о выполнении кода эндпоинта.

# 4. Хранение и управление секретами
![secret](https://github.com/serjteplov/system-design/blob/945ae888a341d7fafaf27dd2ffe0494ebcf34feb/dz5%20-%20security/Secrets.png)

* Токены, которые получает микросервис для доступа к другим сервисам в ландшафте, хранятся в оперативной памяти микросервиса, за хранение отвечает Spring Security.
* Приватные ключи шифрования данных (и сертификаты доступа к Кафке) хранятся в файловой системе сервера где развернут Кубер и монтируются в под при раскатке микросервиса.
* Конфигурации, в которых есть сенсетивные данные, хранятся в зашифрованном виде в Git.
* Пароли (к БД, для OAuth2.0, технические учетные записи) хранятся в Kubernetes secret и монтируются в ENV. Микросервис ходит в БД под своими собственными кредами. Эти креды микросервис загружает в память при старте из ENV переменных пода. В ENV креды попадают при раскатке приложения в Kubernetes. В деплоймент манифесте по раскатке пода указывается что ENV будут созданы из Kubernetes Secret. А в деплоймент манифест креды кладёт Helm, который читает зашифрованный конфиг файл из Git, расшифровывает его, читает от туда пароли, а затем кладет их в формате base64 в Kubernetes Secret.
* Ротация паролей выглядит следующим образом. По расписанию поддержка или девопсы меняют пароль микросервиса к своей БД . Девопс инженер скачивает из Git зашифрованный конфиг файл, расшифровывает его, прописывает новый пароль, потом зашифровывает обратно, и делает push в Git. Данная схема является устаревшей и уязвимой, т.к. пароль в чистом виде проходит через людей, а также может засветиться при сборках, в пайплайнах, логах. Желательно переделать схему хранения и ротации секретов на более зрелое решение, например Hashicorp Vault и настроить выдачу сервисам временных паролей к БД.


# 5. Мониторинг и аудит безопасности
* Микросервисы делают записи в систему аудита безопасности. В систему отправляются события: успешная и неуспешная аутентификация, ошибки авторизации, любые ошибки получения доступа к хранимым данным, протухание токенов и сертификатов, ошибки расшифровки, вызовы сенсетивных эндпоинтов. Сенсетивные данные должны быть замаскированы
* События безопасности логируются в системе аудита безопасности, которая представляет из себя хранилище с удобным поиском, фильтром и UI, систему визуализации, аггрегации и алёртинга, самописные модули/плагины для поиска аномалий. Событие отправляется в формате json, с указанием traceId, sessionId, role, userId. Каждому событию присваивается тэг и уровень угрозы
* События отправляются через в кафку в Elasticsearch (Elastic SIEM), доступ к которой имеют инженеры безопасности с определенной ролью. Логи должны быть защищены от модификации, удаления, экспорта
* Мониторинг анамального поведение ситемы: 10 попыток неудачного ввода пароля, смена IP-адреса после неудачного ввода пароля, повторное использование access token но с другого IP











