# Задание
Вам поручено разработать и оптимизировать архитектуру системы, которая должна обрабатывать запросы пользователей с минимальной задержкой и высокой доступностью. Система должна быть способна справляться с пиковыми нагрузками, обеспечивать отказоустойчивость и предоставлять стабильный уровень производительности. Вы также должны провести анализ производительности и предложить улучшения.

# 1. Масштабирование системы:
* Диаграмма 
![System-design-dz1-ДЗ-3.jpg](System-design-dz1-%D0%94%D0%97-3.jpg)
* Стоит отметить что сервис "Бизнес-процесс" является универсальным оркестратором. В нем обрабатываются все долгоживущие бизнес-процессы. В последующих итерациях развития системы планируется его разбиение на несколько микросервисов по типу бизнес-функций, возложенных на данный сервис
* **Выбор протоколов взаимодействия**. Для нагруженных внутренних межсервисных взаимодействий испольлзуем gRPC. Данные передаются в двоичном формате, что ускоряет передачу данных по сравнению с текстовым протоколом. Также сериализация и десериализация Protobuf на стороне клиентов и источников происходит горазо быстрее. Слабонагруженные внутренние взаимодействия будем делать через REST, чтобы не усложнять реализацию. Общение фронта с бэком, где требуется обновления данных в реальном времени, будет происходить через WebSocket.
* Все внутренние взаимодействия будем строить на базе http/2. Использовать http/3 для системы нецелесообразно по причине сложности разработки (не все фреймворки поддерживают, может потребоваться дополнительная настройка сервера), а также повышенного потребления ресурсов на малых нагрузках, в то время как выигрыш по скорости будет незначительный. 
* Для внешних взаимодействий также оставим http/2, по причине небольших нагрузок

# 2. Проектирование и реализация API:
* Спроектируем API для сервиса заявок. Ресурс, для которого будем строить API, это "Заявка"
*  **Выделим список эндпоинтов:**\
      Создание зявки, POST /applications\
      Создание заявок батчем, POST /applications/batch\
      Отмена заявки, POST /applications/{id}/cancel\
      Чтение заявки, GET /applications/{id}\
      Фильтр заявок, GET /applications?appliedFrom=2025-03-01&appliedTo=2025-03-02&status=PROCESSING\
      Поиск по всем заявкам, GET /applications/search?q=ложка
* Спецификация в формате Openapi представлена в файле:
[application-openapi.yml](application-openapi.yml)
# 3. Использование систем сообщений:
* Между микросервисом "Бизнес-процесс" и "Сервис отчетов" организовано асинхронное взаимодействие через Rabbit. Асинхронное взаимодействие типа точка-точка выбрано потому что из "Бизнес-процесса" возможны одновременные вызовы генерации различных отчетов, в то время как нам нужна гарнтия формирования отчета в случае отказа "Сервиса отчетов". Бизнес процесс запускает тяжёлую задачу построения отчета. Когда отчет будет готов, "Сервис отчетов" отправляет по WebSocket уведомление на фронт в React приложение.

# 4. API Gateway:
* Как единую точку входа в кластер используем API Gateway
* Настроим API Gateway на работу с двумя протоколами: WebSocket и REST
* Настроим балансировку траффика для равномерного распределения нагрузки
* Настроим кросс-функциональность сбора логов и метрик 
* Добавим траффик менеджмент: Throttling, Circuit Breaker

# 5. Как будет вести себя система в случае отказов:
* У данной системы есть 5 критичных сервисов. Если ломается любой из них, то вся система считается неработоспособной и отсчитывается downtime
* Однако 2 сервиса не являются критичными, их падение может ухудшить работу системы, но не вывести ее из строя
* Если ломается "Сервис отчетов", то пользователю на фронт отчеты будут поступать с сильной задержкой. Однако покупка товара и его учет будут происходить корректно. После того как "Сервис отчетов" поднимется, он завершит разгребание очереди и через увеличенный интервал вернет пользователю сформированный отчет о покупке.
* Если ломается "Сервис нотификации", то пользователю не придёт письмо о совершенной покупке, но при этом сама покупка будет корректно проведена и оформлена. Спустя некоторое время, обновив интерфейс в приложении, пользователь увидит что покупка завершилась успешно. За счет механизма fall back, реализованного на стороне "Бизнес-процесса", основной процесс не упадет.
